# 正規表現

- 正規表現のチェックサイト
  - [Rubular](https://rubular.com/)

## [初心者歓迎！手と目で覚える正規表現入門・その１「さまざまな形式の電話番号を検索しよう」](https://qiita.com/jnchito/items/893c887fbf19e17d3ff9)

### 正規表現とは

- パターンを指定して、文字列を効率よく検索・置換するためのミニ言語
- 英語ではRegular Expression
  - 略してRegexpとかRegexなどと書かれることが多い

### 電話番号を探す

- 「\d」は1個の半角数字を表す
- 「03-1234-5678」なら「\d\d-\d\d\d\d-\d\d\d\d」が対応

### いろんな市外局番に対応させる

- 対象となる電話番号

  ```bash
  電話：03-1234-5678
  電話：090-1234-5678
  電話：0795-12-3456
  電話：04992-1-2345
  ```

- {n, m}で「直前の文字のn回以上m回以下の連続」を表す
  - 「\d{2,5}-\d{1,4}-\d{4}」

### ハイフンだけでなく、カッコにも対応する

- 区切りがハイフンとカッコ両方使われていたら？

- 対象となる電話番号

  ```bash
  電話：03(1234)5678
  電話：090-1234-5678
  電話：0795(12)3456
  電話：04992-1-2345
  ```

- [-(]で「ハイフンまたはカッコ開きのいずれか1文字」を表す
  - 「\d{2,5}[-(]\d{1,4}[-)]\d{4}」

#### []中のハイフンは注意が必要

- [A-Z]だと「AまたはBまたは...Z」の意味になる
- ハイフンが[]内の最初または最後に置かれた場合は純粋にハイフン記号を表す
- 例
  - [0-9]なら「0または1または...9」
  - 「-09」なら「-または0または9」

### 検索の精度と正規表現の複雑さについて

- 「\d{2,5}[-(]\d{1,4}[-)]\d{4}」では不十分
  - 「9999-99-9999」のような存在しない電話番号をはじけない
  - 「03-1234)5678」のようなハイフンとカッコが混在している文字列もマッチしてしまう
- ただ、こういったイレギュラーを排除しようとするとかなり複雑な正規表現になる
  - 現実的に「100%完璧でなくてもそこそこ正しくチェックできる正規表現」を使用する
    - どのレベルなのかは要件によって変わる
  - ある程度は正規表現でチェックした上で、プログラミング言語の機能で精度を上げるということもよくある
- 「1文字目はゼロ、2文字目は0以外の半角数字」を条件に追加してみる
  - 「0[1-9]\d{0,3}[-(]\d{1,4}[-)]\d{4}」

## [初心者歓迎！手と目で覚える正規表現入門・その２「微妙な違いを許容しつつ置換しよう」](https://qiita.com/jnchito/items/64c3fdc53766ac6f2008)

### カタカナの表記揺れを許容する

- 「クープ バゲット」っぽい文字列を探す

- 対象となる文字列

  ```bash
  クープバゲットのパンは美味しかった。
  今日はクープ バゲットさんに行きました。
  クープ　バゲットのパンは最高。
  ジャムおじさんのパン、ジャムが入ってた。
  また行きたいです。クープ・バゲット。
  クープ・バケットのパン、売り切れだった（><）
  ```

#### さまざまな区切り文字を許容する

- 半角スペース、全角スペース、中黒を入れた「クープ[ 　・]バゲット」

#### 濁点の有無を許容する

- 「クープ[ 　・]バ[ゲケ]ット」

#### 区切り文字の有無を許容する

- そもそも区切り文字がないパターンも許容する
  - 「クープ[ 　・]?バ[ゲケ]ット」
- 「?」は「直前の文字やパターンが0回または1回」

#### 区切り文字を簡易的に表現する

- 「[ 　・]」の部分は「任意の1文字」で良い
  - 「クープ.?バ[ゲケ]ット」
- 「.」は「任意の1文字」を表す

### HTMLタグをCSVへ変換する

- 正規表現は検索だけではなく置換にも便利
- htmlのoptionタグ部分を抜き出してCSVに変換したい

  ```html
  <!-- sample.html -->
  <select name="game_console">
  <option value="wii_u">Wii U</option>
  <option value="ps4">プレステ4</option>
  <option value="gb">ゲームボーイ</option>
  </select>
  ```

  ```csv
  wii_u,Wii U
  ps4,プレステ4
  gb,ゲームボーイ
  ```

#### valueを抜き出す正規表現を考える

- optionのvalueと表示テキストを正規表現を使って抜き出す
- valueのパターン
  - 「value=、ダブルクオート、英数字またはアンダースコアが1文字以上、ダブルクオート」
  - 「value="[0-9a-z_]+"」
    - `[0-9a-z_]+`以外はメタ文字ではないただの文字
- 「+」は「直前の文字が1文字以上」

#### 表示テキストを抜き出す正規表現を考える

- 「>」と「<」に挟まれている部分
  - 任意の文字列が任意の回数連続する
    - 「>.+<」

#### ここからどうやってCSV形式に置換するか？

1. 行全体にマッチする正規表現を作る
2. valueと表示テキストの部分をそれぞれ( )で囲んでキャプチャする
3. キャプチャを利用して新しい文字列を組み立てる（カンマ区切りの？）

#### 1. 行全体にマッチする正規表現を作る

- `<option value="[0-9a-z_]+">.+<\/option>`

#### 2. valueと表示テキストの部分をそれぞれ( )で囲んでキャプチャする

- `<option value="([0-9a-z_]+)">(.+)<\/option>`
- 正規表現に`(　)`を使うと、その部分がキャプチャされて連番がつけられる
  - Rubularでも「Match groups:」という欄に表示される

#### 3. キャプチャを利用して新しい文字列を組み立てる

- VSCodeで実行してみる
  - 置き換え対象欄に`<option value="([0-9a-z_]+)">(.+)<\/option>`
  - 置き換え後の欄に「$1, $2」を入力してReplaceすると、カンマ区切りになってる！

### 表示テキストがないoptionも置換できるようにする

- `<option value="none"></option>`もマッチするようにする

  ```html
  <select name="game_console">
    <option value="none"></option>
    <option value="wii_u">Wii U</option>
    <option value="ps4">プレステ4</option>
    <option value="gb">ゲームボーイ</option>
  </select>
  ```

- 「.+」を「.*」に変更すれば良い
  - `<option value="([0-9a-z_]+)">(.*)<\/option>`

### selectedになっているoptionも置換できるようにする

- optionの1つにselectedを追加

  ```html
  <select name="game_console">
    <option value="none"></option>
    <option value="wii_u" selected>Wii U</option>
    <option value="ps4">プレステ4</option>
    <option value="gb">ゲームボーイ</option>
  </select>
  ```

- 自分で書いたもの
  - `<option value="([0-9a-z_]+)"[a-z\s]*>(.*)<\/option>`
    - 「a~zの文字列または半角スペースが0回以上連続する」
    - これでもRubularでうまくいった
- 記事で紹介されていたもの
  - `<option value="([0-9a-z_]+)"( selected)?>(.*)<\/option>`
  - 「 selected」だけを決め打ち
  - 『パターン「 selected」が0回または1回現れる』ことを意味している
  - ただし、これだと「( selected)」部分もキャプチャされてしまう
    - キャプチャが必要ないカッコには`?:`をつける
  - `<option value="([0-9a-z_]+)"(?: selected)?>(.*)<\/option>`

- [0-9]は\dに置き換え可能
  - `<option value="([a-z\d_]+)"(?: selected)?>(.*)<\/option>`

- 「a-z\d」は「\w」に置き換え可能
  - 「\w」は英単語を構成する文字
  - Ruby、JavaScriptでは[a-zA-Z0-9_]
  - `<option value="(\w+)"(?: selected)?>(.*)<\/option>`

### 重要： * と + は「貪欲」であることに注意！

- 例
  - 正規表現：`<option value="(\w+)"(?: selected)?>(.*)<\/option>`を使って検索
  - 対象： `<option value="ps4">プレステ4</option><option value="gb">ゲームボーイ</option>`
  - 結果
    > 1.ps4
    >
    > 2.`プレステ4</option><option value="gb">ゲームボーイ`
  - `>.*<`の「任意の文字列が0個以上連続し」の部分がおかしい

- `+`や`*`は**貪欲なマッチを試みる量指定子**と呼ばれる
  - パターンの結果として矛盾がなければ、貪欲に最長のマッチを返す

#### 解決策1：「任意の1文字」よりも厳しい条件を指定する

- 「任意の1文字」より厳しい条件に変更する
  - 「<以外の任意の文字」にする
  - [^<]

- `<option value="(\w+)"(?: selected)?>([^<]*)<\/option>`

#### 解決策2:最短のマッチを返すように指定する

- 「>(.*)<」の意味
  - 「>で始まり、任意の文字を0回以上繰り返し、**最後に見つかった**<で終わる」
- 「>で始まり、任意の文字を0回以上繰り返し、**最初に見つかった**<で終わる」に変える
- 「*?」「+?」にすると最短のマッチを結果として返すようにできる
  - これを**最小量指定子**や**控えめなマッチ**という
  - ただし、実行環境によっては使えない場合がある
- `<option value="(\w+)"(?: selected)?>(.*?)<\/option>`

#### 注意：ミスが許されない置換は1個ずつ確認しながら実行しましょう

- 上記のように、ミスしたらまずい置換は1部分ずつ確認しながら実行していく
- もしくはオリジナルファイルのバックアップをとっておく

## 初心者歓迎！手と目で覚える正規表現入門・その３「空白文字を自由自在に操ろう」

### スペースやタブの入った空行を見つける

- 空白に含まれているスペースやタブを削除する
- 対象スクリプト

  ```ruby

  def hello(name)
    puts "Hello, #{name}!"
  end

  hello('Alice')
            
  hello('Bob')
    
  hello('Carol')

  ```

- `^ +$`で空行が含まれるスペースだけを検出できる
  - と記事に書いてあったが、Rubularで試しても何もマッチしなかった
- `^[ \t]+$`でタブ文字が含まれる空行も検出できる

### 空行に含まれる無駄なスペースやタブ文字を削除する

- VSCodeでは「^[ \t]+$」で検索しても何もマッチしなかった
  - Rubyのコードは勝手にフォーマットしてくれちゃうから

### インデントがガタガタになったスペースを削除する

- `^[ \t]+`で行頭のスペースとタブを削除できる
- sample.txt

### 不揃いなスペースを揃える

- 例
  - `:`の後のスペースの数が不揃い
    - 0個、1個、2個以上

  ```ruby
  {
    japan:	'yen',
    america:'dollar',
    italy:     'euro'
  }
  ```

- `:[ \t]*`で検出して`: `で置き換え

#### [ \t]の代わりに「\s」を使ってみる

- `\s`は半角スペース、タブ文字、**改行文字**などの目に見えない空白文字全般を表す
  - ただし、`\s`に含まれる文字は言語によって異なるので注意
- `:[ \t]*`は`:\s*`に書き換えられる

### カンマ区切りをタブ区切りに、タブ区切りをカンマ区切りに置換する

- カンマ区切り -> タブ区切り
  - `,` から `\t`

### ログから特定の文字を含む行を削除する

- 正規表現を使って、「sample.log」からスケジューラの実行ログを削除する

- 自分で書いてみたやつ
  - これでapiとschedulerだけ行頭から行末まで指定される
  - `^[\w\d\s:]+heroku\/(?:api|scheduler)[\w\d\s:.=]*$`

- 模範回答
  - `^.+heroku\/(?:api|scheduler).+$`
    - apiとschedulerの前後の文字はなんであっても良いので、`.+`で良かった
  - ただ、上記だと置換した後空白行が残ってしまうので、末尾の改行ごと置換する
  - `^.+heroku\/(?:api|scheduler).+\n`

#### 補足：Windows環境とMac/Linux環境の改行コードの違いを考慮する

- Windowsの改行コードは`\r\n`なので上記ではマッチしない
- OSによらずマッチするようにする
- `^.+heroku\/(?:api|scheduler).+\r?\n`

### コラム：使われる場所によって役割が異なる ^ を理解する

- `[^AB]`は「AでもなくBでもない任意の1文字
- `[AB^]`は「AかBか^」
- `^.`は行頭にくる任意の1文字
- `\^`は「^」だけ

## [初心者歓迎！手と目で覚える正規表現入門・その４（最終回）「中級者テクニックをマスターしよう」](https://qiita.com/jnchito/items/b0839f4f4651c29da408)

### 英単語にぴったりマッチさせる（\b の使い方）

- 英文から"ear"だけを抜き出す
  - 普通に「ear」とだけ入力すると、"hearing", "bear"なども引っかかってしまう

  > sounds that are pleasing to the ear.  
  > ear is the organ of the sense of hearing.  
  > I can't bear it.  
  > Why on earth would anyone feel sorry for you?  

- 「単語の境界」を表すメタ文字「\b」を使用する
  - `\bear\b`と入力すれば"ear"だけを抜き出せる

### 検索性の低いメソッドをきれいに抜き出す（\b の使い方・その２）

- rubyのコード内で「t」メソッドを使っている箇所だけを抜き出す

  ```html
  <td>
  <%= link_to I18n.t('.show'), user %>
  <%= link_to t('.edit'), edit_user_path(user) %>
  </td>
  ```

- 「t」メソッドの後ろにはピリオド、カッコ、スペースなどが入る可能性がある
  - これらは正規表現上すべて単語の境界と見なされる
  - `\bt\b`と入力すれば良い

### ファイル名だけをピタリと抜き出す（肯定の後読み）

- 以下からファイル名だけを抜き出したい

  ```ruby
  type=zip; filename=users.zip; size=1024;
  type=xml; filename=posts.xml; size=2048;
  ```

- `filename=[^;]+`だと"filename="部分もマッチしてしまう
- `filename=([^;]+)`とすれば、RubularのMatch Group欄にファイル名だけが出力される
  - これをプログラムか何かで操作しても良い
- 今回は「肯定の後読み」というテクニックが使える
  - 一般に`(?<=abc)`と書くと、"abc"という文字列の直後の位置にマッチする
  - `(?<=filename=)`と入力すると、`filename=`の直後がハイライトされた状態になる
- `(?<=filename=)[^;]+`と入力すればファイル名だけがマッチする
  - 「`filename=`という文字列の直後から始まって、";"以外の文字が1文字以上続く」ことを表す

#### Rubyでの使用例

- 肯定の後読みを使う場合

  ```ruby
  text = <<-TEXT
  type=zip; filename=users.zip; size=1024;
  type=xml; filename=posts.xml; size=2048;
  TEXT
  text.scan(/(?<=filename=)[^;]+/)
  # => ["users.zip", "posts.xml"]
  ```

- 後読みを使わない場合
  - scanで取り除く

  ```ruby
  text = <<-TEXT
  type=zip; filename=users.zip; size=1024;
  type=xml; filename=posts.xml; size=2048;
  TEXT
  text.scan(/filename=[^;]+/).map { |s| s.split('=').last }
  # => ["users.zip", "posts.xml"]
  ```

#### 注意：JavaScript や Atom では「後読み」が使えません

- JSでは`(?<= )`を使ってもエラーになる
  - 記事公開当初はそうだったが、現在は使えるようになっている可能性もある。。

### 特定の楽器を担当しているメンバーを抜き出す（肯定の先読み）

- 以下からベースを担当しているメンバーを抜き出す

  ```ruby
  John:guitar, George:guitar, Paul:bass, Ringo:drum
  Freddie:vocal, Brian:guitar, John:bass, Roger:drum
  ```

- `\w+:bass`だと"Paul:bass"のようになり、"bass"部分が邪魔
- 肯定の先読みというテクニックを使う
  - `(?=:bass)`と入力すると、「:bass」の直前の位置にマッチする
- `\w+(?=:bass)`

- RUbyで使った場合

  ```ruby
  text = <<-TEXT
  John:guitar, George:guitar, Paul:bass, Ringo:drum
  Freddie:vocal, Brian:guitar, John:bass, Roger:drum
  TEXT
  text.scan(/\w+(?=:bass)/)
  # => ["Paul", "John"]
  ```

- 先読みはJavaScriptやAtomでも使える

### 間違った都道府県名を見つける（否定の後読み）

- 先読みと後読みは否定条件を指定することもできる

- 以下のような誤ったテキストがあるとする

  > 東京都  
  > 千葉県  
  > 神奈川県  
  > 埼玉都  

- `(?<!abc)`とすると"abc"という文字列以外の「直後の位置」にマッチする
- `(?<!東京)都`と入力すると"埼玉都"の"都"にマッチする

- 否定の後読みもJSやAtomでは使えない

### 「食べ物のサザエ」を見つける（否定の先読み）

- 以下のテキストから「食べ物のサザエ」を抜き出す

  > つぼ焼きにしたサザエはおいしい  
  > 日曜日にやってるサザエさんは面白い  

- `(?!abc)`のように書くと"abc"という文字列以外の「直前の位置」にマッチする
- `サザエ(?!さん)`とすると、「食べ物のサザエ」を抜き出せる
  - "さん"以外の直前に出てくる「サザエ」を出せるため

- 否定の先読みはJSやAtomでも使える

### まとめ

| 名称         | 例       | 意味                              |
| ------------ | -------- | --------------------------------- |
| 肯定的後読み | (?<=abc) | "abc"の「直後の位置」にマッチ     |
| 肯定的先読み | (?=abc)  | "abc"の「直前の位置」にマッチ     |
| 否定的後読み | (?<!abc) | "abc"以外の「直後の位置」にマッチ |
| 否定的先読み | (?!abc)  | "abc"以外の「直前の位置」にマッチ |

### URLがそのまま画面上に表示されているリンクを見つける（後方参照）

- 第2回で扱った$1, \1は置換する時以外にも使える
- 以下では`\1`は「`()`でキャプチャされた1番目の文字」を表す
  - これを後方参照という

- 例：URLがそのまま画面上に表示されているリンクを検索
  - `<a href="(.+?)">\1<\/a>`

    ```html
    <a href="http://google.com">http://google.com</a>
    <a href="http://yahoo.co.jp">ヤフー</a>
    <a href="http://facebook.com">http://facebook.com</a>
    ```

### ツイート、アカウント、ツイート日時を抽出する（メタ文字の複雑な組み合わせ）

- 以下からツイート、アカウント、ツイート日時をそれぞれ抽出する

  ```bash
  You say yes. - @jnchito 8s
  I say no. - @BarackObama 12m
  You say stop. - @dhh 7h
  I say go go go. - @ladygaga Feb 20
  Hello, goodbye. - @BillGates 11 Apr 2015
  ```

- ツイート
  - 私の回答
    - `.+(?=\s-) `
  - 模範回答
    - 行頭からハイフンまでの任意の文字列：`(^.*) - `

- アカウント
  - ＠で始まり、任意のアルファベットが続く文字列：`(@\w*)`

- ツイート日時
  - 色々なパターンがあるので、まずそれぞれに対応する正規表現を考える
    - 数字 + s/m/h
      - `\d+[smh]`
    - アルファベット3文字 + 日付
      - `([A-Z][a-z]{2} \d+)`
        - "Apr 2015"にもマッチしてしまうが一旦これでOK
    - 日付 + アルファベット3文字 + 年
      - 同時に「アルファベット3文字 + 日付」も抜き出す
        - `((?: \d+ )?[A-Z][a-z]{2} \d+)`

  - 以上を踏まえて、すべての日時を一度に抜き出すには
    - `(\d+[smh]|(?: \d+ )?[A-Z][a-z]{2} \d+)`

#### 仕上げ：ツイート、アカウント、日時を一気に抜き出す

`^(.*) - (@\w+) (\d+[smh]|(?:\d+ )?[A-Z][a-z]{2} \d+)`

### ツールを使ってパフォーマンスの善し悪しを確認する

`(_+|\w+)*a`のように`+`や`*`が`()`の中にも外にもあると、組み合わせの数が爆発的に増えてとんでもなく遅くなる可能性がある。

[Online regex tester and debugger](https://regex101.com/)でマッチする（またはマッチに失敗する）までのステップ数をカウントできるので、パフォーマンスの良し悪しを確認してから実行する方が良い。

### 小文字とは逆の意味になる \W \S \D \B

- `\W`：英単語の構成文字以外（記号や空白など）
- `\D`：半角数字以外
- `\S`：空白文字以外
- `\B`：単語の境界以外の位置

## [正規表現で名前付きキャプチャを使う](https://qiita.com/jnchito/items/cceb669cb06fc044f411)

- `()`でキャプチャした部分に名前をつける方法について

### 名前付きキャプチャを使って置換する

- `(?<name>pattern)`

- 例
  - 年月日
    - `(?<year>\d{4})-(?<month>\d{2})-(?<date>\d{2})`

    - 置換する場合は`\k<name>`という文字列を指定する

      ```ruby
      s = '2016-05-08'
      puts s.gsub(
        /(?<year>\d+)-(?<month>\d+)-(?<day>\d+)/, 
        '\k<year>年\k<month>月\k<day>日'
      )
      ```

### 名前付きキャプチャを変数に入れる

```ruby
s = '2016-05-08'
if m = s.match(/(?<year>\d+)-(?<month>\d+)-(?<day>\d+)/)
  year  = m[:year]
  month = m[:month]
  day   = m[:day]
  puts "year: #{year}, month: #{month}, day: #{day}"
  # => year: 2016, month: 05, day: 08
end
```

- 直接ローカル変数にアサインする場合

  ```ruby
  s = '2016-05-08'
  if /(?<year>\d+)-(?<month>\d+)-(?<day>\d+)/ =~ s
    # 名前付きキャプチャがそのままローカル変数になる
    puts "year: #{year}, month: #{month}, day: #{day}"
    # => year: 2016, month: 05, day: 08
  end
  ```

- 名前付きでないキャプチャを使用する場合

  ```ruby
  s = '2016-05-08'
  if m = s.match(/(\d+)-(\d+)-(\d+)/)
    year  = m[1]
    month = m[2]
    day   = m[3]
    puts "year: #{year}, month: #{month}, day: #{day}"
    # => year: 2016, month: 05, day: 08
  end
  ```

### 後方参照で名前付きキャプチャを使う

```ruby
# HTMLからhrefのURLと表示テキストの内容が全く一緒のリンク（aタグ）を抜き出す
html = '<p>Please visit <a href="http://google.com">http://google.com</a>.</p>'

# 正規表現で該当するリンクを抜き出す。\1が連番で後方参照されている部分
puts html[/<a href="(.+?)">\1<\/a>/]
# => <a href="http://google.com">http://google.com</a>
```

- 後方参照の場合も`?<name>`や`\k<name>`で名前付きキャプチャを使える

```ruby
html = '<p>Please visit <a href="http://google.com">http://google.com</a>.</p>'

# 名前付きキャプチャと後方参照を組み合わせる
puts html[/<a href="(?<url>.+?)">\k<url><\/a>/]
# => <a href="http://google.com">http://google.com</a>
```
