# 正規表現

- 正規表現のチェックサイト
  - [Rubular](https://rubular.com/)

## [初心者歓迎！手と目で覚える正規表現入門・その１「さまざまな形式の電話番号を検索しよう」](https://qiita.com/jnchito/items/893c887fbf19e17d3ff9)

### 正規表現とは

- パターンを指定して、文字列を効率よく検索・置換するためのミニ言語
- 英語ではRegular Expression
  - 略してRegexpとかRegexなどと書かれることが多い

### 電話番号を探す

- 「\d」は1個の半角数字を表す
- 「03-1234-5678」なら「\d\d-\d\d\d\d-\d\d\d\d」が対応

### いろんな市外局番に対応させる

- 対象となる電話番号

  ```bash
  電話：03-1234-5678
  電話：090-1234-5678
  電話：0795-12-3456
  電話：04992-1-2345
  ```

- {n, m}で「直前の文字のn回以上m回以下の連続」を表す
  - 「\d{2,5}-\d{1,4}-\d{4}」

### ハイフンだけでなく、カッコにも対応する

- 区切りがハイフンとカッコ両方使われていたら？

- 対象となる電話番号

  ```bash
  電話：03(1234)5678
  電話：090-1234-5678
  電話：0795(12)3456
  電話：04992-1-2345
  ```

- [-(]で「ハイフンまたはカッコ開きのいずれか1文字」を表す
  - 「\d{2,5}[-(]\d{1,4}[-)]\d{4}」

#### []中のハイフンは注意が必要

- [A-Z]だと「AまたはBまたは...Z」の意味になる
- ハイフンが[]内の最初または最後に置かれた場合は純粋にハイフン記号を表す
- 例
  - [0-9]なら「0または1または...9」
  - 「-09」なら「-または0または9」

### 検索の精度と正規表現の複雑さについて

- 「\d{2,5}[-(]\d{1,4}[-)]\d{4}」では不十分
  - 「9999-99-9999」のような存在しない電話番号をはじけない
  - 「03-1234)5678」のようなハイフンとカッコが混在している文字列もマッチしてしまう
- ただ、こういったイレギュラーを排除しようとするとかなり複雑な正規表現になる
  - 現実的に「100%完璧でなくてもそこそこ正しくチェックできる正規表現」を使用する
    - どのレベルなのかは要件によって変わる
  - ある程度は正規表現でチェックした上で、プログラミング言語の機能で精度を上げるということもよくある
- 「1文字目はゼロ、2文字目は0以外の半角数字」を条件に追加してみる
  - 「0[1-9]\d{0,3}[-(]\d{1,4}[-)]\d{4}」

## [初心者歓迎！手と目で覚える正規表現入門・その２「微妙な違いを許容しつつ置換しよう」](https://qiita.com/jnchito/items/64c3fdc53766ac6f2008)

### カタカナの表記揺れを許容する

- 「クープ バゲット」っぽい文字列を探す

- 対象となる文字列

  ```bash
  クープバゲットのパンは美味しかった。
  今日はクープ バゲットさんに行きました。
  クープ　バゲットのパンは最高。
  ジャムおじさんのパン、ジャムが入ってた。
  また行きたいです。クープ・バゲット。
  クープ・バケットのパン、売り切れだった（><）
  ```

#### さまざまな区切り文字を許容する

- 半角スペース、全角スペース、中黒を入れた「クープ[ 　・]バゲット」

#### 濁点の有無を許容する

- 「クープ[ 　・]バ[ゲケ]ット」

#### 区切り文字の有無を許容する

- そもそも区切り文字がないパターンも許容する
  - 「クープ[ 　・]?バ[ゲケ]ット」
- 「?」は「直前の文字やパターンが0回または1回」

#### 区切り文字を簡易的に表現する

- 「[ 　・]」の部分は「任意の1文字」で良い
  - 「クープ.?バ[ゲケ]ット」
- 「.」は「任意の1文字」を表す

### HTMLタグをCSVへ変換する

- 正規表現は検索だけではなく置換にも便利
- htmlのoptionタグ部分を抜き出してCSVに変換したい

  ```html
  <!-- sample.html -->
  <select name="game_console">
  <option value="wii_u">Wii U</option>
  <option value="ps4">プレステ4</option>
  <option value="gb">ゲームボーイ</option>
  </select>
  ```

  ```csv
  wii_u,Wii U
  ps4,プレステ4
  gb,ゲームボーイ
  ```

#### valueを抜き出す正規表現を考える

- optionのvalueと表示テキストを正規表現を使って抜き出す
- valueのパターン
  - 「value=、ダブルクオート、英数字またはアンダースコアが1文字以上、ダブルクオート」
  - 「value="[0-9a-z_]+"」
    - `[0-9a-z_]+`以外はメタ文字ではないただの文字
- 「+」は「直前の文字が1文字以上」

#### 表示テキストを抜き出す正規表現を考える

- 「>」と「<」に挟まれている部分
  - 任意の文字列が任意の回数連続する
    - 「>.+<」

#### ここからどうやってCSV形式に置換するか？

1. 行全体にマッチする正規表現を作る
2. valueと表示テキストの部分をそれぞれ( )で囲んでキャプチャする
3. キャプチャを利用して新しい文字列を組み立てる（カンマ区切りの？）

#### 1. 行全体にマッチする正規表現を作る

- `<option value="[0-9a-z_]+">.+<\/option>`

#### 2. valueと表示テキストの部分をそれぞれ( )で囲んでキャプチャする

- `<option value="([0-9a-z_]+)">(.+)<\/option>`
- 正規表現に`(　)`を使うと、その部分がキャプチャされて連番がつけられる
  - Rubularでも「Match groups:」という欄に表示される

#### 3. キャプチャを利用して新しい文字列を組み立てる

- VSCodeで実行してみる
  - 置き換え対象欄に`<option value="([0-9a-z_]+)">(.+)<\/option>`
  - 置き換え後の欄に「$1, $2」を入力してReplaceすると、カンマ区切りになってる！

### 表示テキストがないoptionも置換できるようにする

- `<option value="none"></option>`もマッチするようにする

  ```html
  <select name="game_console">
    <option value="none"></option>
    <option value="wii_u">Wii U</option>
    <option value="ps4">プレステ4</option>
    <option value="gb">ゲームボーイ</option>
  </select>
  ```

- 「.+」を「.*」に変更すれば良い
  - `<option value="([0-9a-z_]+)">(.*)<\/option>`

### selectedになっているoptionも置換できるようにする

- optionの1つにselectedを追加

  ```html
  <select name="game_console">
    <option value="none"></option>
    <option value="wii_u" selected>Wii U</option>
    <option value="ps4">プレステ4</option>
    <option value="gb">ゲームボーイ</option>
  </select>
  ```

- 自分で書いたもの
  - `<option value="([0-9a-z_]+)"[a-z\s]*>(.*)<\/option>`
    - 「a~zの文字列または半角スペースが0回以上連続する」
    - これでもRubularでうまくいった
- 記事で紹介されていたもの
  - `<option value="([0-9a-z_]+)"( selected)?>(.*)<\/option>`
  - 「 selected」だけを決め打ち
  - 『パターン「 selected」が0回または1回現れる』ことを意味している
  - ただし、これだと「( selected)」部分もキャプチャされてしまう
    - キャプチャが必要ないカッコには`?:`をつける
  - `<option value="([0-9a-z_]+)"(?: selected)?>(.*)<\/option>`

- [0-9]は\dに置き換え可能
  - `<option value="([a-z\d_]+)"(?: selected)?>(.*)<\/option>`

- 「a-z\d」は「\w」に置き換え可能
  - 「\w」は英単語を構成する文字
  - Ruby、JavaScriptでは[a-zA-Z0-9_]
  - `<option value="(\w+)"(?: selected)?>(.*)<\/option>`

### 重要： * と + は「貪欲」であることに注意！

- 例
  - 正規表現：`<option value="(\w+)"(?: selected)?>(.*)<\/option>`を使って検索
  - 対象： `<option value="ps4">プレステ4</option><option value="gb">ゲームボーイ</option>`
  - 結果
    > 1.ps4
    >
    > 2.`プレステ4</option><option value="gb">ゲームボーイ`
  - `>.*<`の「任意の文字列が0個以上連続し」の部分がおかしい

- `+`や`*`は**貪欲なマッチを試みる量指定子**と呼ばれる
  - パターンの結果として矛盾がなければ、貪欲に最長のマッチを返す

#### 解決策1：「任意の1文字」よりも厳しい条件を指定する

- 「任意の1文字」より厳しい条件に変更する
  - 「<以外の任意の文字」にする
  - [^<]

- `<option value="(\w+)"(?: selected)?>([^<]*)<\/option>`

#### 解決策2:最短のマッチを返すように指定する

- 「>(.*)<」の意味
  - 「>で始まり、任意の文字を0回以上繰り返し、**最後に見つかった**<で終わる」
- 「>で始まり、任意の文字を0回以上繰り返し、**最初に見つかった**<で終わる」に変える
- 「*?」「+?」にすると最短のマッチを結果として返すようにできる
  - これを**最小量指定子**や**控えめなマッチ**という
  - ただし、実行環境によっては使えない場合がある
- `<option value="(\w+)"(?: selected)?>(.*?)<\/option>`

#### 注意：ミスが許されない置換は1個ずつ確認しながら実行しましょう

- 上記のように、ミスしたらまずい置換は1部分ずつ確認しながら実行していく
- もしくはオリジナルファイルのバックアップをとっておく

## 初心者歓迎！手と目で覚える正規表現入門・その３「空白文字を自由自在に操ろう」

### スペースやタブの入った空行を見つける

- 空白に含まれているスペースやタブを削除する
- 対象スクリプト

  ```ruby

  def hello(name)
    puts "Hello, #{name}!"
  end

  hello('Alice')
            
  hello('Bob')
    
  hello('Carol')

  ```

- `^ +$`で空行が含まれるスペースだけを検出できる
  - と記事に書いてあったが、Rubularで試しても何もマッチしなかった
- `^[ \t]+$`でタブ文字が含まれる空行も検出できる

### 空行に含まれる無駄なスペースやタブ文字を削除する

- VSCodeでは「^[ \t]+$」で検索しても何もマッチしなかった
  - Rubyのコードは勝手にフォーマットしてくれちゃうから

### インデントがガタガタになったスペースを削除する

- `^[ \t]+`で行頭のスペースとタブを削除できる
- sample.txt

### 不揃いなスペースを揃える

- 例
  - `:`の後のスペースの数が不揃い
    - 0個、1個、2個以上

  ```ruby
  {
    japan:	'yen',
    america:'dollar',
    italy:     'euro'
  }
  ```

- `:[ \t]*`で検出して`: `で置き換え

#### [ \t]の代わりに「\s」を使ってみる

- `\s`は半角スペース、タブ文字、**改行文字**などの目に見えない空白文字全般を表す
  - ただし、`\s`に含まれる文字は言語によって異なるので注意
- `:[ \t]*`は`:\s*`に書き換えられる

### カンマ区切りをタブ区切りに、タブ区切りをカンマ区切りに置換する

- カンマ区切り -> タブ区切り
  - `,` から `\t`

### ログから特定の文字を含む行を削除する

- 正規表現を使って、「sample.log」からスケジューラの実行ログを削除する

- 自分で書いてみたやつ
  - これでapiとschedulerだけ行頭から行末まで指定される
  - `^[\w\d\s:]+heroku\/(?:api|scheduler)[\w\d\s:.=]*$`

- 模範回答
  - `^.+heroku\/(?:api|scheduler).+$`
    - apiとschedulerの前後の文字はなんであっても良いので、`.+`で良かった
  - ただ、上記だと置換した後空白行が残ってしまうので、末尾の改行ごと置換する
  - `^.+heroku\/(?:api|scheduler).+\n`

#### 補足：Windows環境とMac/Linux環境の改行コードの違いを考慮する

- Windowsの改行コードは`\r\n`なので上記ではマッチしない
- OSによらずマッチするようにする
- `^.+heroku\/(?:api|scheduler).+\r?\n`

### コラム：使われる場所によって役割が異なる ^ を理解する

- `[^AB]`は「AでもなくBでもない任意の1文字
- `[AB^]`は「AかBか^」
- `^.`は行頭にくる任意の1文字
- `\^`は「^」だけ
